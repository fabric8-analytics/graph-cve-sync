#!/usr/bin/env python3
# Copyright Â© 2020 Red Hat Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Author: Yusuf Zainee <yzainee@redhat.com>
#

"""Helper functions for the graph sync operations."""

import requests
import logging
import os
import boto3
import json

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Helper:
    """Helper class with some utility functions."""

    def __init__(self):
        """Init method for helper class."""
        self.CVE_BUCKET = os.environ.get("REPORT_BUCKET_NAME", '')
        self.AWS_KEY = os.environ.get("AWS_S3_ACCESS_KEY_ID_REPORT_BUCKET", '')
        self.AWS_SECRET = os.environ.get("AWS_S3_SECRET_ACCESS_KEY_REPORT_BUCKET", '')
        self.AWS_REGION = os.environ.get("AWS_S3_REGION", "us-east-1")
        self.HOST = os.environ.get('BAYESIAN_DATA_IMPORTER_SERVICE_HOST', 'bayesian-data-importer')
        self.PORT = os.environ.get('BAYESIAN_DATA_IMPORTER_SERVICE_PORT', '9192')

        self.s3_resource = boto3.resource('s3', aws_access_key_id=self.AWS_KEY,
                                          aws_secret_access_key=self.AWS_SECRET,
                                          region_name=self.AWS_REGION)

    def store_json_content(self, content, obj_key):
        """Store the report content to the S3 storage."""
        try:
            logger.info('Storing the data into the S3 file %s' % obj_key)
            self.s3_resource.Object(self.CVE_BUCKET, obj_key).put(
                Body=json.dumps(content, indent=2).encode('utf-8'))
        except Exception as e:
            logger.exception('%r' % e)

    def _retrieve_dict(self, object_key):
        """Retrieve a dictionary stored as JSON from S3."""
        return json.loads(self._retrieve_blob(object_key).decode('utf-8'))

    def _retrieve_blob(self, object_key):
        """Retrieve remote object content."""
        return self.s3_resource.Object(self.CVE_BUCKET, object_key).get()['Body'].read()

    def read_data_from_s3(self, date, loc):
        """Read the snyk data from S3."""
        try:
            filename = loc + date + ".json"
            logger.info('Retrieving the data from the S3 file %s' % filename)
            return self._retrieve_dict(filename)
        except Exception as e:
            logger.error(e)
            return False

    def make_api_call(self, payload, mode):
        """Make an API call to data importer."""
        try:
            api_url = "http://" + self.HOST + ":" + self.PORT
            headers = {'Content-type': 'application/json'}
            msg = ""
            response = ""
            if mode == "PUT":
                response = requests.put('{}/api/v1/snyk-cves'.format(api_url), headers=headers,
                                        data=json.dumps(payload))
                msg = "ingested"
                key = payload['package']
            elif mode == "DELETE":
                response = requests.delete('{}/api/v1/snyk-cves'.format(api_url), headers=headers,
                                           data=json.dumps(payload))
                msg = "deleted"
                key = payload['id']
            if response.status_code == 200:
                logger.info("CVEs for {p} successfully {m}".format(p=key, m=msg))
                return "success"
            elif response.status_code == 504:
                logger.info("Operation for {p} is taking time. "
                            "Will be {m} in the background".format(p=key, m=msg))
                return "delayed"
            else:
                logger.info("Error while {m} CVEs for {p}".format(p=key, m=msg))
                logger.info("Status Code {}".format(response.status_code))
            return "failed"
        except Exception:
            logger.error("API call to data importer failed.")

    def is_dry_run(self):
        """Return True if this is a dry run."""
        # Set this value to true if you want the entire operation to run, but not the ingestion.
        return os.environ.get('SNYK_DRY_RUN', 'false').lower() in ('1', 'yes', 'true')

    def force_run_ingestion(self):
        """Return if ingestion mode is on."""
        # Set this value when you want to run the ingestion forcefully (ignores runtime).
        return os.environ.get('SNYK_INGESTION_FORCE_RUN', 'false').lower() in ('1', 'yes', 'true')

    def is_delta_mode_on(self):
        """Return if the delta feed mode is on."""
        # Set this value if you want to run only in the diff mode.
        return os.environ.get('SNYK_DELTA_FEED_MODE', 'false').lower() in ('1', 'yes', 'true')

    def ingestion_run_time(self):
        """Return the time when ingestion needs to run."""
        # Set the time at which you want the ingestion to run.
        return os.environ.get('SNYK_INGESTION_RUN_TIME', '12')